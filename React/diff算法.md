### React创建DOM流程
1. 创建虚拟DOM
2. 真是DOM连接虚拟DOM
3. 视图更新
4. 计算新的虚拟DOM和旧的虚拟DOM的差异(diff算法)
5. 根据计算的差异更新真是DOM

### React的DIFF策略
- DOM节点跨层级的移动操作特别少，可以忽略不计
- 拥有相同类的两个组件会生成相似的数据结构
- 对于同一层级的组件可以使用ID来区分

### tree diff
**核心思想**：同层比较
基于策略一，对树进行分层比较，也就是同层之间比较，这样的好处就是只需要一次遍历就可以完成对VDOM的比较
那么万一出现DOM跨层级操作怎么办呢，diff算法会认为，先创建了新的节点，再删除了以前老的节点

```js
createA ---> createB ---> createC ---> deleteA
```
由于出现节点跨层级操作时，并不会出现想象中的移动操作，而是以A为根节点进行整个树的重建。这是一种非常损耗性能的操作，官方并不推荐

### component diff
组件之间的diff算法是非常简洁的
- 相同类型的组件：按照原策略继续比较VDOM即可，React会对属性进行重设从而实现节点的转换

```js
renderA: <div id="before" />
renderB: <div id="after" />
=> [replaceAttribute id "after"]
```

- 非同类型的组件：则将该组件判断为`dirty component`，从而替换组件下面所有的子节点。因为不同类型的组件往往对应不同的子节点类型，与其浪费时间比较，不如直接创建一个新的组件

```js
renderA : <Header />
renderB : <Content />
=> [removeNode <Header />] [insertNode <Content />]
```

### element diff
当元素处于同一层级时，diff提供了三种节点操作，分别是`插入、移动、删除`
- 插入：新的组件类型不在旧的集合中，即为全新的节点，需要对新节点执行插入操作
- 移动：旧的集合中有新组件的类型，且element是可更新的类型，这时候就需要做移动操作
- 删除：旧组件类型，在新的集合里有，但对应的element不同则不能直接复用和更新，需要执行删除操作。或者旧组件不在新集合中，也需要执行删除操作

比如现在有以下通层级的VDOM

```js
A -- B -- C -- D
// 需要变化为
B -- A -- D -- C
```
React对于这种只是移动性质的VDOM变化，允许给同一层级的同组子节点，添加唯一key进行区分，虽然只是小小的改动，但是性能上却发生了翻天覆地的变化。添加key之后无需进行节点的删除和创建，只需要将旧的集合中节点的位置进行移动，更新为新的节点即可。因此上述变话，BD无需发生改变，移动AC即可

![图片](http://box.kancloud.cn/2015-09-24_5603ab976202e.png)
